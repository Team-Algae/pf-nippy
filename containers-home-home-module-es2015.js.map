{"version":3,"sources":["./src/app/@containers/home/home.page.route.ts","./src/app/@containers/home/home.module.ts","./src/app/@components/navigation/navigation.component.ts","./src/app/@components/navigation/navigation.component.html","./node_modules/ngx-page-scroll-core/__ivy_ngcc__/fesm2015/ngx-page-scroll-core.js","./node_modules/ngx-page-scroll/__ivy_ngcc__/fesm2015/ngx-page-scroll.js","./src/app/@containers/home/home.page.ts","./src/app/@containers/home/home.page.html","./src/app/@containers/home/home-routing.module.ts","./src/app/@components/navigation/navigation.module.ts"],"names":[],"mappings":";;;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAqC;AACE;AAEhC,MAAM,UAAU,GAAU;IAC/B,IAAI,EAAE,kDAAI,CAAC,IAAI;IACf,SAAS,EAAE,mDAAQ;IACnB,IAAI,EAAE;QACJ,KAAK,EAAE,MAAM;QACb,WAAW,EACT,2FAA2F;QAC7F,MAAM,EAAE,eAAe;KACxB;CACF,CAAC;;;;;;;;;;;;;ACbF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA+C;AAEkC;AACvB;AACnB;;AAShC,MAAM,UAAU;;yFAAV,UAAU;8IAAV,UAAU,kBALZ;YACP,4DAAY;YACZ,sEAAiB;YACjB,6FAAgB;SAAC;mIAER,UAAU,mBANN,mDAAQ,aAErB,4DAAY;QACZ,sEAAiB;QACjB,6FAAgB;;;;;;;;;;;;;;;;;;;;;ACJb,MAAM,mBAAmB;IAI9B;QAFA,WAAM,GAAG,IAAI,CAAC;IAEE,CAAC;IAEjB,QAAQ;IACR,CAAC;;sFAPU,mBAAmB;mGAAnB,mBAAmB;QCNhC,4EAEE;QAAA,yEACE;QAAA,yEACE;QAAA,uEAA8C;QAAA,gEAAK;QAAA,4DAAI;QACzD,4DAAM;QACR,4DAAM;QAEN,yEACE;QADwF,oKAA0B;QAClH,0EACE;QAAA,qEAAqC;QACvC,4DAAO;QACT,4DAAM;QAEN,yEACE;QAAA,sEACE;QAAA,yEACE;QAAA,sEACE;QAAA,wEACgB;QAAA,oEAAQ;QAAA,4DAAI;QAC9B,4DAAK;QACL,sEACE;QAAA,wEACa;QAAA,gEAAI;QAAA,4DAAI;QACvB,4DAAK;QACL,sEACE;QAAA,wEACgB;QAAA,qEAAS;QAAA,4DAAI;QAC/B,4DAAK;QACL,sEACE;QAAA,wEACgB;QAAA,gEAAI;QAAA,4DAAI;QAC1B,4DAAK;QACL,sEACE;QAAA,wEACgB;QAAA,oEAAQ;QAAA,4DAAI;QAC9B,4DAAK;QACP,4DAAK;QACP,4DAAM;QACR,4DAAM;QACR,4DAAS;;QAhCF,0DAAqC;QAArC,kGAAqC;QAMrC,0DAAkC;QAAlC,+FAAkC;;;;;;;;;;;;;;ACfzC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAsH;;AAEtH;AACA;AACA;AACwC;AACxC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,0BAA0B;AAC1B;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,4DAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,oDAAoD;AACpD;AACA,0EAA0E,+DAAS;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA,0FAA0F,yBAAyB;AACnH;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E;AAC7E;AACA;AACA;AACA;AACA,6EAA6E,+DAAS;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,+DAAS;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,+DAAS;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,+DAAS;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,+DAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kCAAkC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,qCAAqC,sDAAe,gBAAgB;AACpI;AACA,0BAA0B,wEAAkB,EAAE,gDAAgD,8BAA8B,8DAAQ,gBAAgB,EAAE,gDAAgD;AACtM;AACA,KAAK,gCAAgC,OAAO,oDAAM,yBAAyB;AAC3E;AACA,4BAA4B,CAAC,+DAAwB;AACrD,cAAc,wDAAU;AACxB;AACA;AACA,aAAa;AACb,KAAK,gBAAgB,UAAU;AAC/B,sBAAsB,oDAAM;AAC5B;AACA,aAAa,GAAG,EAAE,EAAE,QAAQ,EAAE;;AAE9B;AACA;AACA;AACA;AACA;AACA,4CAA4C,0CAA0C;AACtF;AACA;AACA;AACA,+BAA+B,8DAAuB,EAAE,gCAAgC;AACxF,+BAA+B,8DAAuB,EAAE,uDAAuD,6CAA6C,EAAE;AAC9J;AACA,SAAS,wCAAwC;AACjD,OAAO;AACP,4BAA4B,CAAC,+DAAwB;AACrD,cAAc,sDAAQ;AACtB;AACA;AACA;AACA,qBAAqB,wCAAwC;AAC7D;AACA,aAAa;AACb,KAAK,eAAe,EAAE;;AAEtB;AACA;AACA;;AAEA;AACA;AACA;;AAEiH;;AAEjH,gD;;;;;;;;;;;;ACpfA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAmG;AACjB;AACS;AAChD;AACG;;AAE9C;AACwC;AACO;AACL;AAC1C;AACA;AACA;AACA;AACA;AACA,oCAAoC,0DAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;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","file":"containers-home-home-module-es2015.js","sourcesContent":["import { Route } from '@angular/router';\nimport { Path } from '@core/structs';\nimport { HomePage } from './home.page';\n\nexport const HOME_ROUTE: Route = {\n  path: Path.Home,\n  component: HomePage,\n  data: {\n    title: 'Home',\n    description:\n      'Start writing your business logic right away without any concern on architecture matters.',\n    robots: 'index, follow',\n  },\n};\n","import { CommonModule } from '@angular/common';\nimport { NgModule } from '@angular/core';\nimport { NavigationModule } from '@app/@components/navigation/navigation.module';\nimport { HomeRoutingModule } from './home-routing.module';\nimport { HomePage } from './home.page';\n\n@NgModule({\n  declarations: [HomePage],\n  imports: [\n    CommonModule,\n    HomeRoutingModule,\n    NavigationModule],\n})\nexport class HomeModule { }\n","import { Component, OnInit } from '@angular/core';\n\n@Component({\n  selector: 'algae-navigation',\n  templateUrl: './navigation.component.html',\n  styleUrls: ['./navigation.component.scss']\n})\nexport class NavigationComponent implements OnInit {\n\n  toggle = true;\n\n  constructor() { }\n\n  ngOnInit(): void {\n  }\n\n}\n","<!-- ref: https://github.com/justalever/tailwind-navbar/blob/master/public/index.html -->\n<header id=\"header\"\n  class=\"flex flex-wrap items-center px-6 py-2 mx-auto font-bold bg-white lg:px-16 lg:py-0 font-montserrat\">\n  <div class=\"flex items-center justify-between flex-1\">\n    <div class=\"flex items-center justify-between flex-1\">\n      <a class=\"text-2xl text-black\" routerLink=\"/\">Nippy</a>\n    </div>\n  </div>\n\n  <div [ngClass]=\"toggle ? '' : 'is-active'\" class=\"hamburger hamburger--elastic lg:hidden\" (click)=\"toggle = !toggle\">\n    <span class=\"hamburger-box\">\n      <span class=\"hamburger-inner\"></span>\n    </span>\n  </div>\n\n  <div [ngClass]=\"toggle ? 'hidden' : ''\" class=\"w-full lg:w-auto lg:flex lg:items-center\" id=\"menu\">\n    <nav>\n      <ul class=\"items-center justify-between pt-4 text-base text-gray-700 lg:flex lg:pt-0\">\n        <li>\n          <a class=\"block px-0 py-3 border-b-2 border-transparent lg:p-4 hover:text-primary-900\" pageScroll\n            href=\"#hello\">ABOUT US</a>\n        </li>\n        <li>\n          <a class=\"block px-0 py-3 border-b-2 border-transparent lg:p-4 hover:text-primary-900\" pageScroll\n            href=\"#hi\">SHOP</a>\n        </li>\n        <li>\n          <a class=\"block px-0 py-3 border-b-2 border-transparent lg:p-4 hover:text-primary-900\" pageScroll\n            href=\"#hello\">PORTFOLIO</a>\n        </li>\n        <li>\n          <a class=\"block px-0 py-3 border-b-2 border-transparent lg:p-4 hover:text-primary-900\" pageScroll\n            href=\"#hello\">BLOG</a>\n        </li>\n        <li>\n          <a class=\"block px-0 py-3 border-b-2 border-transparent lg:p-4 hover:text-primary-900\" pageScroll\n            href=\"#hello\">ELEMENTS</a>\n        </li>\n      </ul>\n    </nav>\n  </div>\n</header>\n","import { InjectionToken, isDevMode, ɵɵdefineInjectable, ɵɵinject, Injectable, Inject, NgModule } from '@angular/core';\n\n/**\n * Represents a scrolling action\n */\nimport * as ɵngcc0 from '@angular/core';\nclass PageScrollInstance {\n    /**\n     * Private constructor, requires the properties assumed to be the bare minimum.\n     * Use the factory methods to create instances:\n     *      {@link PageScrollService#create}\n     */\n    constructor(pageScrollOptions) {\n        /**\n         * These properties will be set/manipulated if the scroll animation starts\n         */\n        /* The initial value of the scrollTop or scrollLeft position when the animation starts */\n        this.startScrollPosition = 0;\n        /* Whether an interrupt listener is attached to the body or not */\n        this.interruptListenersAttached = false;\n        /* References to the timer instance that is used to perform the scroll animation to be\n         able to clear it on animation end*/\n        this.timer = null;\n        if (!pageScrollOptions.scrollViews || pageScrollOptions.scrollViews.length === 0) {\n            pageScrollOptions.scrollViews = [\n                pageScrollOptions.document.documentElement,\n                pageScrollOptions.document.body,\n                pageScrollOptions.document.body.parentNode,\n            ];\n            this.isInlineScrolling = false;\n        }\n        else {\n            this.isInlineScrolling = true;\n        }\n        this.pageScrollOptions = pageScrollOptions;\n    }\n    static getScrollingTargetPosition(pageScrollOptions, scrollTargetElement) {\n        const body = pageScrollOptions.document.body;\n        const docEl = pageScrollOptions.document.documentElement;\n        const windowPageYOffset = pageScrollOptions.document.defaultView &&\n            pageScrollOptions.document.defaultView.pageYOffset || undefined;\n        const windowPageXOffset = pageScrollOptions.document.defaultView &&\n            pageScrollOptions.document.defaultView.pageXOffset || undefined;\n        const scrollTop = windowPageYOffset || docEl.scrollTop || body.scrollTop;\n        const scrollLeft = windowPageXOffset || docEl.scrollLeft || body.scrollLeft;\n        const clientTop = docEl.clientTop || body.clientTop || 0;\n        const clientLeft = docEl.clientLeft || body.clientLeft || 0;\n        if (scrollTargetElement === undefined || scrollTargetElement === null) {\n            // No element found, so return the current position to not cause any change in scroll position\n            return { top: scrollTop, left: scrollLeft };\n        }\n        const box = scrollTargetElement.getBoundingClientRect();\n        const top = box.top + scrollTop - clientTop;\n        const left = box.left + scrollLeft - clientLeft;\n        return { top: Math.round(top), left: Math.round(left) };\n    }\n    static getInlineScrollingTargetPosition(pageScrollOptions, scrollTargetElement) {\n        const position = { top: scrollTargetElement.offsetTop, left: scrollTargetElement.offsetLeft };\n        if (pageScrollOptions.advancedInlineOffsetCalculation && pageScrollOptions.scrollViews.length === 1) {\n            const accumulatedParentsPos = { top: 0, left: 0 };\n            // not named window to make sure we're not getting the global window variable by accident\n            const theWindow = scrollTargetElement.ownerDocument.defaultView;\n            let parentFound = false;\n            // Start parent is the immediate parent\n            let parent = scrollTargetElement.parentElement;\n            // Iterate upwards all parents\n            while (!parentFound && parent !== undefined && parent !== null) {\n                if (theWindow.getComputedStyle(parent).getPropertyValue('position') === 'relative') {\n                    accumulatedParentsPos.top += parent.offsetTop;\n                    accumulatedParentsPos.left += parent.offsetLeft;\n                }\n                // Next iteration\n                parent = parent.parentElement;\n                parentFound = parent === pageScrollOptions.scrollViews[0];\n            }\n            if (parentFound) {\n                // Only use the results if we found the parent, otherwise we accumulated too much anyway\n                position.top += accumulatedParentsPos.top;\n                position.left += accumulatedParentsPos.left;\n            }\n            else {\n                /* TODO Uncomment\n                if (PageScrollConfig._logLevel >= 2 || (PageScrollConfig._logLevel >= 1 && isDevMode())) {\n                  console.warn('Unable to find nested scrolling targets parent!');\n                }*/\n            }\n        }\n        return position;\n    }\n    getScrollPropertyValue(scrollingView) {\n        if (!this.pageScrollOptions.verticalScrolling) {\n            return scrollingView.scrollLeft;\n        }\n        return scrollingView.scrollTop;\n    }\n    getScrollClientPropertyValue(scrollingView) {\n        if (!this.pageScrollOptions.verticalScrolling) {\n            return scrollingView.clientWidth;\n        }\n        return scrollingView.clientHeight;\n    }\n    /**\n     * Extract the exact location of the scrollTarget element.\n     *\n     * Extract the scrollTarget HTMLElement from the given PageScrollTarget object. The latter one may be\n     * a string like \"#heading2\", then this method returns the corresponding DOM element for that id.\n     *\n     */\n    extractScrollTargetPosition() {\n        const scrollTargetElement = this.getScrollTargetElement();\n        if (scrollTargetElement === null || scrollTargetElement === undefined) {\n            // Scroll target not found\n            return { top: NaN, left: NaN };\n        }\n        if (this.isInlineScrolling) {\n            return PageScrollInstance.getInlineScrollingTargetPosition(this.pageScrollOptions, scrollTargetElement);\n        }\n        return PageScrollInstance.getScrollingTargetPosition(this.pageScrollOptions, scrollTargetElement);\n    }\n    /**\n     * Get the top offset of the scroll animation.\n     * This automatically takes the offset location of the scrolling container/scrolling view\n     * into account (for nested/inline scrolling).\n     */\n    getCurrentOffset() {\n        return this.pageScrollOptions.scrollOffset;\n    }\n    /**\n     * Sets the \"scrollTop\" or \"scrollLeft\" property for all scrollViews to the provided value\n     * @return true if at least for one ScrollTopSource the scrollTop/scrollLeft value could be set and it kept the new value.\n     *          false if it failed for all ScrollViews, meaning that we should stop the animation\n     *          (probably because we're at the end of the scrolling region)\n     */\n    setScrollPosition(position) {\n        // Set the new scrollTop/scrollLeft to all scrollViews elements\n        return this.pageScrollOptions.scrollViews.reduce((oneAlreadyWorked, scrollingView) => {\n            const startScrollPropertyValue = this.getScrollPropertyValue(scrollingView);\n            if (scrollingView && startScrollPropertyValue !== undefined && startScrollPropertyValue !== null) {\n                const scrollDistance = Math.abs(startScrollPropertyValue - position);\n                // The movement we need to perform is less than 2px\n                // This we consider a small movement which some browser may not perform when\n                // changing the scrollTop/scrollLeft property\n                // Thus in this cases we do not stop the scroll animation, although setting the\n                // scrollTop/scrollLeft value \"fails\"\n                const isSmallMovement = scrollDistance < this.pageScrollOptions._minScrollDistance;\n                if (!this.pageScrollOptions.verticalScrolling) {\n                    scrollingView.scrollLeft = position;\n                }\n                else {\n                    scrollingView.scrollTop = position;\n                }\n                // Return true if setting the new scrollTop/scrollLeft value worked\n                // We consider that it worked if the new scrollTop/scrollLeft value is closer to the\n                // desired scrollTop/scrollLeft than before (it might not be exactly the value we\n                // set due to dpi or rounding irregularities)\n                if (isSmallMovement || scrollDistance > Math.abs(this.getScrollPropertyValue(scrollingView) - position)) {\n                    return true;\n                }\n            }\n            return oneAlreadyWorked;\n        }, false);\n    }\n    /**\n     * Trigger firing a animation finish event\n     * @param value Whether the animation finished at the target (true) or got interrupted (false)\n     */\n    fireEvent(value) {\n        if (this.pageScrollOptions.scrollFinishListener) {\n            this.pageScrollOptions.scrollFinishListener.emit(value);\n        }\n    }\n    /**\n     * Attach the interrupt listeners to the PageScrollInstance body. The given interruptReporter\n     * will be called if any of the attached events is fired.\n     *\n     * Possibly attached interruptListeners are automatically removed from the body before the new one will be attached.\n     */\n    attachInterruptListeners(interruptReporter) {\n        if (this.interruptListenersAttached) {\n            // Detach possibly existing listeners first\n            this.detachInterruptListeners();\n        }\n        this.interruptListener = (event) => {\n            interruptReporter.report(event, this);\n        };\n        this.pageScrollOptions.interruptEvents.forEach((event) => this.pageScrollOptions.document.body.addEventListener(event, this.interruptListener));\n        this.interruptListenersAttached = true;\n    }\n    /**\n     * Remove event listeners from the body and stop listening for events that might be treated as \"animation\n     * interrupt\" events.\n     */\n    detachInterruptListeners() {\n        this.pageScrollOptions.interruptEvents.forEach((event) => this.pageScrollOptions.document.body.removeEventListener(event, this.interruptListener));\n        this.interruptListenersAttached = false;\n    }\n    getScrollTargetElement() {\n        if (typeof this.pageScrollOptions.scrollTarget === 'string') {\n            const targetSelector = this.pageScrollOptions.scrollTarget;\n            if (targetSelector.match(/^#[^\\s]+$/g) !== null) {\n                // It's an id selector and a valid id, as it does not contain any white space characters\n                return this.pageScrollOptions.document.getElementById(targetSelector.substr(1));\n            }\n            return this.pageScrollOptions.document.querySelector(targetSelector);\n        }\n        return this.pageScrollOptions.scrollTarget;\n    }\n}\n\nconst NGXPS_CONFIG = new InjectionToken('ngxps_config');\nconst ɵ0 = (t, b, c, d) => {\n    // Linear easing\n    return c * t / d + b;\n};\nconst defaultPageScrollConfig = {\n    _interval: 10,\n    _minScrollDistance: 2,\n    _logLevel: 1,\n    namespace: 'default',\n    verticalScrolling: true,\n    duration: 1250,\n    scrollOffset: 0,\n    advancedInlineOffsetCalculation: false,\n    interruptEvents: ['mousedown', 'wheel', 'DOMMouseScroll', 'mousewheel', 'keyup', 'touchmove'],\n    interruptKeys: [' ', 'Escape', 'Tab', 'Enter', 'PageUp', 'PageDown', 'Home', 'End', 'ArrowUp', 'ArrowRight', 'ArrowLeft', 'ArrowDown'],\n    interruptible: true,\n    scrollInView: true,\n    easingLogic: ɵ0,\n};\n\nclass PageScrollService {\n    constructor(customConfig) {\n        this.runningInstances = [];\n        this.onInterrupted = {\n            report: (event, pageScrollInstance) => {\n                if (!pageScrollInstance.pageScrollOptions.interruptible) {\n                    // Non-interruptible anyway, so do not stop anything\n                    return;\n                }\n                let shouldStop = true;\n                if (event.type === 'keyup') {\n                    // Only stop if specific keys have been pressed, for all others don't stop anything\n                    if (this.config.interruptKeys.indexOf(event.key) === -1) {\n                        // The pressed key is not in the list of interrupting keys\n                        shouldStop = false;\n                    }\n                }\n                else if (event.type === 'mousedown') {\n                    // For mousedown events we only stop the scroll animation of the mouse has\n                    // been clicked inside the scrolling container\n                    if (!pageScrollInstance.pageScrollOptions.scrollViews.some(scrollingView => scrollingView.contains(event.target))) {\n                        // Mouse clicked an element which is not inside any of the the scrolling containers\n                        shouldStop = false;\n                    }\n                }\n                if (shouldStop) {\n                    this.stopAll(pageScrollInstance.pageScrollOptions.namespace);\n                }\n            },\n        };\n        this.config = Object.assign(Object.assign({}, defaultPageScrollConfig), customConfig);\n        if (PageScrollService.instanceCounter > 0 &&\n            (this.config._logLevel >= 2 || (this.config._logLevel >= 1 && isDevMode()))) {\n            console.warn('An instance of PageScrollService already exists, usually ' +\n                'including one provider should be enough, so double check.');\n        }\n        PageScrollService.instanceCounter++;\n    }\n    stopInternal(interrupted, pageScrollInstance) {\n        const index = this.runningInstances.indexOf(pageScrollInstance);\n        if (index >= 0) {\n            this.runningInstances.splice(index, 1);\n        }\n        if (pageScrollInstance.interruptListenersAttached) {\n            pageScrollInstance.detachInterruptListeners();\n        }\n        if (pageScrollInstance.timer) {\n            // Clear/Stop the timer\n            clearInterval(pageScrollInstance.timer);\n            // Clear the reference to this timer\n            pageScrollInstance.timer = undefined;\n            pageScrollInstance.fireEvent(!interrupted);\n            return true;\n        }\n        return false;\n    }\n    create(options) {\n        return new PageScrollInstance(Object.assign(Object.assign({}, this.config), options));\n    }\n    /**\n     * Start a scroll animation. All properties of the animation are stored in the given {@link PageScrollInstance} object.\n     *\n     * This is the core functionality of the whole library.\n     */\n    // tslint:disable-next-line:cyclomatic-complexity\n    start(pageScrollInstance) {\n        // Merge the default options in the pageScrollInstance options\n        pageScrollInstance.pageScrollOptions = Object.assign(Object.assign({}, this.config), pageScrollInstance.pageScrollOptions);\n        // Stop all possibly running scroll animations in the same namespace\n        this.stopAll(pageScrollInstance.pageScrollOptions.namespace);\n        if (pageScrollInstance.pageScrollOptions.scrollViews === null || pageScrollInstance.pageScrollOptions.scrollViews.length === 0) {\n            // No scrollViews specified, thus we can't animate anything\n            if (this.config._logLevel >= 2 || (this.config._logLevel >= 1 && isDevMode())) {\n                console.warn('No scrollViews specified, thus ngx-page-scroll does not know which DOM elements to scroll');\n            }\n            return;\n        }\n        let startScrollPositionFound = false;\n        let scrollRange = pageScrollInstance.getScrollClientPropertyValue(pageScrollInstance.pageScrollOptions.scrollViews[0]);\n        // Reset start scroll position to 0. If any of the scrollViews has a different one, it will be extracted next\n        pageScrollInstance.startScrollPosition = 0;\n        // Get the start scroll position from the scrollViews (e.g. if the user already scrolled down the content)\n        pageScrollInstance.pageScrollOptions.scrollViews.forEach(scrollingView => {\n            if (scrollingView === undefined || scrollingView === null) {\n                return;\n            }\n            // Get the scrollTop or scrollLeft value of the first scrollingView that returns a value for its \"scrollTop\"\n            // or \"scrollLeft\" property that is not undefined and unequal to 0\n            const scrollPosition = pageScrollInstance.getScrollPropertyValue(scrollingView);\n            if (!startScrollPositionFound && scrollPosition) {\n                // We found a scrollingView that does not have scrollTop or scrollLeft 0\n                // Return the scroll position value, as this will be our startScrollPosition\n                pageScrollInstance.startScrollPosition = scrollPosition;\n                startScrollPositionFound = true;\n                // Remember te scrollRange of this scrollingView\n                scrollRange = pageScrollInstance.getScrollClientPropertyValue(scrollingView);\n            }\n        });\n        const pageScrollOffset = pageScrollInstance.getCurrentOffset();\n        // Calculate the target position that the scroll animation should go to\n        const scrollTargetPosition = pageScrollInstance.extractScrollTargetPosition();\n        pageScrollInstance.targetScrollPosition = Math.round((pageScrollInstance.pageScrollOptions.verticalScrolling ? scrollTargetPosition.top : scrollTargetPosition.left) - pageScrollOffset);\n        // Calculate the distance we need to go in total\n        pageScrollInstance.distanceToScroll = pageScrollInstance.targetScrollPosition - pageScrollInstance.startScrollPosition;\n        if (isNaN(pageScrollInstance.distanceToScroll)) {\n            // We weren't able to find the target position, maybe the element does not exist?\n            if (this.config._logLevel >= 2 || (this.config._logLevel >= 1 && isDevMode())) {\n                console.log('Scrolling not possible, as we can\\'t find the specified target');\n            }\n            pageScrollInstance.fireEvent(false);\n            return;\n        }\n        // We're at the final destination already\n        // OR we need to scroll down but are already at the end\n        // OR we need to scroll up but are at the top already\n        const allReadyAtDestination = Math.abs(pageScrollInstance.distanceToScroll) < pageScrollInstance.pageScrollOptions._minScrollDistance;\n        // Check how long we need to scroll if a speed option is given\n        // Default executionDuration is the specified duration\n        pageScrollInstance.executionDuration = pageScrollInstance.pageScrollOptions.duration;\n        // Maybe we need to pay attention to the speed option?\n        if ((pageScrollInstance.pageScrollOptions.speed !== undefined && pageScrollInstance.pageScrollOptions.speed !== null) &&\n            (pageScrollInstance.pageScrollOptions.duration === undefined || pageScrollInstance.pageScrollOptions.duration === null)) {\n            // Speed option is set and no duration => calculate duration based on speed and scroll distance\n            pageScrollInstance.executionDuration =\n                Math.abs(pageScrollInstance.distanceToScroll) / pageScrollInstance.pageScrollOptions.speed * 1000;\n        }\n        // We should go there directly, as our \"animation\" would have one big step\n        // only anyway and this way we save the interval stuff\n        const tooShortInterval = pageScrollInstance.executionDuration <= pageScrollInstance.pageScrollOptions._interval;\n        if (allReadyAtDestination || tooShortInterval) {\n            if (this.config._logLevel >= 2 || (this.config._logLevel >= 1 && isDevMode())) {\n                if (allReadyAtDestination) {\n                    console.log('Scrolling not possible, as we can\\'t get any closer to the destination');\n                }\n                else {\n                    console.log('Scroll duration shorter that interval length, jumping to target');\n                }\n            }\n            pageScrollInstance.setScrollPosition(pageScrollInstance.targetScrollPosition);\n            pageScrollInstance.fireEvent(true);\n            return;\n        }\n        if (!pageScrollInstance.pageScrollOptions.scrollInView) {\n            const alreadyInView = pageScrollInstance.targetScrollPosition > pageScrollInstance.startScrollPosition &&\n                pageScrollInstance.targetScrollPosition <= pageScrollInstance.startScrollPosition + scrollRange;\n            if (alreadyInView) {\n                if (this.config._logLevel >= 2 || (this.config._logLevel >= 1 && isDevMode())) {\n                    console.log('Not scrolling, as target already in view');\n                }\n                pageScrollInstance.fireEvent(true);\n                return;\n            }\n        }\n        // Register the interrupt listeners if we want an interruptible scroll animation\n        if (pageScrollInstance.pageScrollOptions.interruptible) {\n            pageScrollInstance.attachInterruptListeners(this.onInterrupted);\n        }\n        // Let's get started, get the start time...\n        pageScrollInstance.startTime = new Date().getTime();\n        // .. and calculate the end time (when we need to finish at last)\n        pageScrollInstance.endTime = pageScrollInstance.startTime + pageScrollInstance.executionDuration;\n        pageScrollInstance.timer = setInterval((instance) => {\n            // Take the current time\n            const currentTime = new Date().getTime();\n            // Determine the new scroll position\n            let newScrollPosition;\n            let stopNow = false;\n            if (instance.endTime <= currentTime) {\n                // We're over the time already, so go the targetScrollPosition (aka destination)\n                newScrollPosition = instance.targetScrollPosition;\n                stopNow = true;\n            }\n            else {\n                // Calculate the scroll position based on the current time using the easing function\n                newScrollPosition = Math.round(instance.pageScrollOptions.easingLogic(currentTime - instance.startTime, instance.startScrollPosition, instance.distanceToScroll, instance.executionDuration));\n            }\n            if (this.config._logLevel >= 5 && isDevMode()) {\n                console.warn('Scroll Position: ' + newScrollPosition);\n            }\n            // Set the new scrollPosition to all scrollViews elements\n            if (!instance.setScrollPosition(newScrollPosition)) {\n                // Setting the new scrollTop/scrollLeft value failed for all ScrollViews\n                // early stop the scroll animation to save resources\n                stopNow = true;\n            }\n            // At the end do the internal stop maintenance and fire the pageScrollFinish event\n            // (otherwise the event might arrive at \"too early\")\n            if (stopNow) {\n                this.stopInternal(false, instance);\n            }\n        }, this.config._interval, pageScrollInstance);\n        // Register the instance as running one\n        this.runningInstances.push(pageScrollInstance);\n    }\n    scroll(options) {\n        this.start(this.create(options));\n    }\n    /**\n     * Stop all running scroll animations. Optionally limit to stop only the ones of specific namespace.\n     */\n    stopAll(namespace) {\n        if (this.runningInstances.length > 0) {\n            let stoppedSome = false;\n            for (let i = 0; i < this.runningInstances.length; ++i) {\n                const pageScrollInstance = this.runningInstances[i];\n                if (!namespace || pageScrollInstance.pageScrollOptions.namespace === namespace) {\n                    stoppedSome = true;\n                    this.stopInternal(true, pageScrollInstance);\n                    // Decrease the counter, as we removed an item from the array we iterate over\n                    i--;\n                }\n            }\n            return stoppedSome;\n        }\n        return false;\n    }\n    stop(pageScrollInstance) {\n        return this.stopInternal(true, pageScrollInstance);\n    }\n}\nPageScrollService.ɵfac = function PageScrollService_Factory(t) { return new (t || PageScrollService)(ɵngcc0.ɵɵinject(NGXPS_CONFIG)); };\nPageScrollService.instanceCounter = 0;\nPageScrollService.ɵprov = ɵɵdefineInjectable({ factory: function PageScrollService_Factory() { return new PageScrollService(ɵɵinject(NGXPS_CONFIG)); }, token: PageScrollService, providedIn: \"root\" });\nPageScrollService.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Inject, args: [NGXPS_CONFIG,] }] }\n];\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PageScrollService, [{\n        type: Injectable,\n        args: [{\n                providedIn: 'root'\n            }]\n    }], function () { return [{ type: undefined, decorators: [{\n                type: Inject,\n                args: [NGXPS_CONFIG]\n            }] }]; }, null); })();\n\nconst ɵ0$1 = {};\nclass NgxPageScrollCoreModule {\n    static forRoot(config) {\n        return {\n            ngModule: NgxPageScrollCoreModule,\n            providers: [PageScrollService, { provide: NGXPS_CONFIG, useValue: config }],\n        };\n    }\n}\nNgxPageScrollCoreModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NgxPageScrollCoreModule });\nNgxPageScrollCoreModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NgxPageScrollCoreModule_Factory(t) { return new (t || NgxPageScrollCoreModule)(); }, providers: [\n        PageScrollService,\n        { provide: NGXPS_CONFIG, useValue: ɵ0$1 },\n    ] });\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxPageScrollCoreModule, [{\n        type: NgModule,\n        args: [{\n                providers: [\n                    PageScrollService,\n                    { provide: NGXPS_CONFIG, useValue: ɵ0$1 },\n                ]\n            }]\n    }], null, null); })();\n\n/*\n * Public API Surface of ngx-page-scroll-core\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NGXPS_CONFIG, NgxPageScrollCoreModule, PageScrollInstance, PageScrollService, defaultPageScrollConfig };\n\n//# sourceMappingURL=ngx-page-scroll-core.js.map","import { EventEmitter, Directive, Optional, Inject, Input, Output, NgModule } from '@angular/core';\nimport { PageScrollService, NgxPageScrollCoreModule } from 'ngx-page-scroll-core';\nimport { NavigationEnd, NavigationError, NavigationCancel, Router } from '@angular/router';\nimport { DOCUMENT } from '@angular/common';\nimport { filter, take } from 'rxjs/operators';\n\n/* tslint:disable:no-host-metadata-property directive-selector */\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from 'ngx-page-scroll-core';\nimport * as ɵngcc2 from '@angular/router';\nclass NgxPageScrollDirective {\n    constructor(pageScrollService, router, document) {\n        this.pageScrollService = pageScrollService;\n        this.router = router;\n        this.pageScrollAdjustHash = false;\n        this.pageScrollFinish = new EventEmitter();\n        this.document = document;\n    }\n    ngOnChanges(changes) {\n        // Some inputs changed, reset the pageScrollInstance\n        this.pageScrollInstance = undefined;\n    }\n    ngOnDestroy() {\n        if (this.pageScrollInstance) {\n            this.pageScrollService.stop(this.pageScrollInstance);\n        }\n    }\n    getPageScrollTarget() {\n        return this.pageScrollTarget || this.href || (this.fragment ? '#' + this.fragment : '');\n    }\n    generatePageScrollInstance() {\n        if (this.pageScrollInstance === undefined || this.pageScrollInstance === null) {\n            const options = {\n                document: this.document,\n                scrollTarget: this.getPageScrollTarget(),\n            };\n            if (this.pageScroll) {\n                options.namespace = this.pageScroll;\n            }\n            if (this.pageScrollHorizontal !== undefined && this.pageScrollHorizontal !== null) {\n                options.verticalScrolling = !this.pageScrollHorizontal;\n            }\n            if (this.pageScrollOffset !== undefined && this.pageScrollOffset !== null) {\n                options.scrollOffset = this.pageScrollOffset;\n            }\n            if (this.pageScrollInterruptible !== undefined && this.pageScrollInterruptible !== null) {\n                options.interruptible = this.pageScrollInterruptible;\n            }\n            if (this.pageScrollInView !== undefined && this.pageScrollInView !== null) {\n                options.scrollInView = this.pageScrollInView;\n            }\n            if (this.pageScrollEasing) {\n                options.easingLogic = this.pageScrollEasing;\n            }\n            if (this.pageScrollDuration !== undefined && this.pageScrollDuration !== null) {\n                options.duration = this.pageScrollDuration;\n            }\n            if (this.pageScrollSpeed !== undefined && this.pageScrollSpeed !== null) {\n                options.speed = this.pageScrollSpeed;\n            }\n            if (this.pageScrollFinish) {\n                options.scrollFinishListener = this.pageScrollFinish;\n            }\n            this.pageScrollInstance = this.pageScrollService.create(options);\n        }\n        return this.pageScrollInstance;\n    }\n    pushRouterState() {\n        if (this.pageScrollAdjustHash && typeof this.pageScrollInstance.pageScrollOptions.scrollTarget === 'string'\n            && this.pageScrollInstance.pageScrollOptions.scrollTarget.substr(0, 1) === '#') {\n            // \"Navigate\" to the current route again and this time set the fragment/hash\n            this.router.navigate([], {\n                fragment: this.pageScrollInstance.pageScrollOptions.scrollTarget.substr(1),\n                queryParamsHandling: 'preserve',\n            });\n        }\n    }\n    scroll() {\n        const pageScrollInstance = this.generatePageScrollInstance();\n        this.pushRouterState();\n        this.pageScrollService.start(pageScrollInstance);\n    }\n    handleClick(clickEvent) {\n        if (this.routerLink && this.router !== null && this.router !== undefined) {\n            let urlTree;\n            if (typeof this.routerLink === 'string') {\n                urlTree = this.router.parseUrl(this.routerLink);\n            }\n            else {\n                urlTree = this.router.createUrlTree(this.routerLink);\n            }\n            if (!this.router.isActive(urlTree, true)) {\n                // We need to navigate their first.\n                // Navigation is handled by the routerLink directive so we only need to listen for route change\n                this.router.events.pipe(filter(routerEvent => {\n                    // We're only interested in successful navigations or when the navigation fails\n                    return routerEvent instanceof NavigationEnd || routerEvent instanceof NavigationError\n                        || routerEvent instanceof NavigationCancel;\n                }), \n                // Consume only one event, automatically \"unsubscribing\" from the event stream afterwards\n                take(1)).subscribe((routerEvent) => {\n                    if (routerEvent instanceof NavigationEnd) {\n                        // use a timeout to start scrolling as soon as the stack is cleared\n                        setTimeout(() => {\n                            this.scroll();\n                        }, 0);\n                    }\n                });\n                return false; // to preventDefault()\n            }\n        }\n        this.scroll();\n        return false; // to preventDefault()\n    }\n}\nNgxPageScrollDirective.ɵfac = function NgxPageScrollDirective_Factory(t) { return new (t || NgxPageScrollDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.PageScrollService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.Router, 8), ɵngcc0.ɵɵdirectiveInject(DOCUMENT)); };\nNgxPageScrollDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgxPageScrollDirective, selectors: [[\"\", \"pageScroll\", \"\"]], hostBindings: function NgxPageScrollDirective_HostBindings(rf, ctx) { if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"click\", function NgxPageScrollDirective_click_HostBindingHandler($event) { return ctx.handleClick($event); });\n    } }, inputs: { pageScrollAdjustHash: \"pageScrollAdjustHash\", routerLink: \"routerLink\", href: \"href\", fragment: \"fragment\", pageScrollTarget: \"pageScrollTarget\", pageScrollHorizontal: \"pageScrollHorizontal\", pageScrollOffset: \"pageScrollOffset\", pageScrollDuration: \"pageScrollDuration\", pageScrollSpeed: \"pageScrollSpeed\", pageScrollEasing: \"pageScrollEasing\", pageScrollInterruptible: \"pageScrollInterruptible\", pageScrollInView: \"pageScrollInView\", pageScroll: \"pageScroll\" }, outputs: { pageScrollFinish: \"pageScrollFinish\" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });\nNgxPageScrollDirective.ctorParameters = () => [\n    { type: PageScrollService },\n    { type: Router, decorators: [{ type: Optional }] },\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }\n];\nNgxPageScrollDirective.propDecorators = {\n    routerLink: [{ type: Input }],\n    href: [{ type: Input }],\n    fragment: [{ type: Input }],\n    pageScrollTarget: [{ type: Input }],\n    pageScrollHorizontal: [{ type: Input }],\n    pageScrollOffset: [{ type: Input }],\n    pageScrollDuration: [{ type: Input }],\n    pageScrollSpeed: [{ type: Input }],\n    pageScrollEasing: [{ type: Input }],\n    pageScrollInterruptible: [{ type: Input }],\n    pageScrollInView: [{ type: Input }],\n    pageScrollAdjustHash: [{ type: Input }],\n    pageScroll: [{ type: Input }],\n    pageScrollFinish: [{ type: Output }]\n};\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxPageScrollDirective, [{\n        type: Directive,\n        args: [{\n                selector: '[pageScroll]',\n                host: {\n                    '(click)': 'handleClick($event)'\n                }\n            }]\n    }], function () { return [{ type: ɵngcc1.PageScrollService }, { type: ɵngcc2.Router, decorators: [{\n                type: Optional\n            }] }, { type: undefined, decorators: [{\n                type: Inject,\n                args: [DOCUMENT]\n            }] }]; }, { pageScrollAdjustHash: [{\n            type: Input\n        }], pageScrollFinish: [{\n            type: Output\n        }], routerLink: [{\n            type: Input\n        }], href: [{\n            type: Input\n        }], fragment: [{\n            type: Input\n        }], pageScrollTarget: [{\n            type: Input\n        }], pageScrollHorizontal: [{\n            type: Input\n        }], pageScrollOffset: [{\n            type: Input\n        }], pageScrollDuration: [{\n            type: Input\n        }], pageScrollSpeed: [{\n            type: Input\n        }], pageScrollEasing: [{\n            type: Input\n        }], pageScrollInterruptible: [{\n            type: Input\n        }], pageScrollInView: [{\n            type: Input\n        }], pageScroll: [{\n            type: Input\n        }] }); })();\n\nclass NgxPageScrollModule {\n}\nNgxPageScrollModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NgxPageScrollModule });\nNgxPageScrollModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NgxPageScrollModule_Factory(t) { return new (t || NgxPageScrollModule)(); }, imports: [[\n            NgxPageScrollCoreModule,\n        ]] });\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxPageScrollModule, { declarations: function () { return [NgxPageScrollDirective]; }, imports: function () { return [NgxPageScrollCoreModule]; }, exports: function () { return [NgxPageScrollDirective]; } }); })();\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxPageScrollModule, [{\n        type: NgModule,\n        args: [{\n                declarations: [\n                    NgxPageScrollDirective,\n                ],\n                imports: [\n                    NgxPageScrollCoreModule,\n                ],\n                exports: [\n                    NgxPageScrollDirective,\n                ]\n            }]\n    }], null, null); })();\n\n/*\n * Public API Surface of ngx-page-scroll\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NgxPageScrollDirective, NgxPageScrollModule };\n\n//# sourceMappingURL=ngx-page-scroll.js.map","import { Component, OnInit } from '@angular/core';\nimport { Path } from '@core/structs';\n\n@Component({\n  templateUrl: './home.page.html',\n  styleUrls: ['./home.page.scss'],\n})\nexport class HomePage implements OnInit {\n  path = Path;\n\n  constructor() {}\n\n  ngOnInit(): void {}\n}\n","<div class=\"min-w-full light\">\n  <algae-navigation></algae-navigation>\n</div>\n","import { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\nimport { HOME_ROUTE } from './home.page.route';\n\nconst routes: Routes = [HOME_ROUTE];\n\n@NgModule({\n  imports: [RouterModule.forChild(routes)],\n  exports: [RouterModule],\n})\nexport class HomeRoutingModule {}\n","import { CommonModule } from '@angular/common';\nimport { NgModule } from '@angular/core';\nimport { NgxPageScrollModule } from 'ngx-page-scroll';\nimport { NgxPageScrollCoreModule } from 'ngx-page-scroll-core';\nimport { NavigationComponent } from './navigation.component';\n\n\n\n@NgModule({\n  declarations: [NavigationComponent],\n  imports: [\n    CommonModule,\n    NgxPageScrollCoreModule.forRoot({ duration: 800 }),\n    NgxPageScrollModule\n  ],\n  exports: [NavigationComponent]\n})\nexport class NavigationModule { }\n"],"sourceRoot":"webpack:///"}